{"version":3,"file":"42.aa3256e95c30941c4f89.js?v=aa3256e95c30941c4f89","mappings":"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","sources":["webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/runtime/ucs2length.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/core/id.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/enum.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/core/ref.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/dataType.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/limitLength.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/not.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/const.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/rules.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/fast-deep-equal/index.js","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/metadata.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/names.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/ajv.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/core/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv-formats/src/formats.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/runtime/validation_error.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/createAjvInstance.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/processRawValidationErrors.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/validator.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/customizeValidator.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/precompiledValidator.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/createPrecompiledValidator.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/@rjsf/validator-ajv8/src/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/discriminator/types.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/util.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/applicability.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv-formats/src/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/pattern.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/node_modules/json-schema-traverse/index.js","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/core.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/allOf.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/ref_error.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/if.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/draft7.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/format/format.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/codegen/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/keyword.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/resolve.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/items.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/properties.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/code.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/errors.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/util.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/regexps-uri.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/regexps-iri.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/node_modules/punycode/punycode.es6.js","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/uri.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/http.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/https.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/ws.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/wss.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/mailto.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/urn.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/schemes/urn-uuid.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/uri-js/src/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/items2020.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/discriminator/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/boolSchema.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/runtime/equal.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/runtime/uri.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/defaults.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/format/index.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/codegen/code.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/codegen/scope.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/required.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/compile/validate/subschema.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/contains.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv-formats/src/limit.ts","webpack://@jupyter-lsp/jupyterlab-lsp/../../node_modules/ajv/lib/vocabularies/validation/limitItems.ts"],"sourcesContent":["// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nclass Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {Format, FormatDefinition} from \"ajv\"\nimport type {FormatValidator, FormatCompare} from \"ajv/dist/types\"\n\nexport type FormatMode = \"fast\" | \"full\"\n\nexport type FormatName =\n  | \"date\"\n  | \"time\"\n  | \"date-time\"\n  | \"duration\"\n  | \"uri\"\n  | \"uri-reference\"\n  | \"uri-template\"\n  | \"url\"\n  | \"email\"\n  | \"hostname\"\n  | \"ipv4\"\n  | \"ipv6\"\n  | \"regex\"\n  | \"uuid\"\n  | \"json-pointer\"\n  | \"json-pointer-uri-fragment\"\n  | \"relative-json-pointer\"\n  | \"byte\"\n  | \"int32\"\n  | \"int64\"\n  | \"float\"\n  | \"double\"\n  | \"password\"\n  | \"binary\"\n\nexport type DefinedFormats = {\n  [key in FormatName]: Format\n}\n\nfunction fmtDef(\n  validate: RegExp | FormatValidator<string>,\n  compare: FormatCompare<string>\n): FormatDefinition<string> {\n  return {validate, compare}\n}\n\nexport const fullFormats: DefinedFormats = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: fmtDef(date, compareDate),\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: fmtDef(time, compareTime),\n  \"date-time\": fmtDef(date_time, compareDateTime),\n  // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n  duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n  uri,\n  \"uri-reference\":\n    /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  \"uri-template\":\n    /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  email:\n    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname:\n    /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n  regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n  \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n  // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n  // byte: https://github.com/miguelmota/is-base64\n  byte,\n  // signed 32 bit integer\n  int32: {type: \"number\", validate: validateInt32},\n  // signed 64 bit integer\n  int64: {type: \"number\", validate: validateInt64},\n  // C-type float\n  float: {type: \"number\", validate: validateNumber},\n  // C-type double\n  double: {type: \"number\", validate: validateNumber},\n  // hint to the UI to hide input strings\n  password: true,\n  // unchecked string payload\n  binary: true,\n}\n\nexport const fastFormats: DefinedFormats = {\n  ...fullFormats,\n  date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n  time: fmtDef(\n    /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    compareTime\n  ),\n  \"date-time\": fmtDef(\n    /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    compareDateTime\n  ),\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n  email:\n    /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n}\n\nexport const formatNames = Object.keys(fullFormats) as FormatName[]\n\nfunction isLeapYear(year: number): boolean {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  const matches: string[] | null = DATE.exec(str)\n  if (!matches) return false\n  const year: number = +matches[1]\n  const month: number = +matches[2]\n  const day: number = +matches[3]\n  return (\n    month >= 1 &&\n    month <= 12 &&\n    day >= 1 &&\n    day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n  )\n}\n\nfunction compareDate(d1: string, d2: string): number | undefined {\n  if (!(d1 && d2)) return undefined\n  if (d1 > d2) return 1\n  if (d1 < d2) return -1\n  return 0\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i\n\nfunction time(str: string, withTimeZone?: boolean): boolean {\n  const matches: string[] | null = TIME.exec(str)\n  if (!matches) return false\n\n  const hour: number = +matches[1]\n  const minute: number = +matches[2]\n  const second: number = +matches[3]\n  const timeZone: string = matches[5]\n  return (\n    ((hour <= 23 && minute <= 59 && second <= 59) ||\n      (hour === 23 && minute === 59 && second === 60)) &&\n    (!withTimeZone || timeZone !== \"\")\n  )\n}\n\nfunction compareTime(t1: string, t2: string): number | undefined {\n  if (!(t1 && t2)) return undefined\n  const a1 = TIME.exec(t1)\n  const a2 = TIME.exec(t2)\n  if (!(a1 && a2)) return undefined\n  t1 = a1[1] + a1[2] + a1[3] + (a1[4] || \"\")\n  t2 = a2[1] + a2[2] + a2[3] + (a2[4] || \"\")\n  if (t1 > t2) return 1\n  if (t1 < t2) return -1\n  return 0\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction date_time(str: string): boolean {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  const dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n  return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true)\n}\n\nfunction compareDateTime(dt1: string, dt2: string): number | undefined {\n  if (!(dt1 && dt2)) return undefined\n  const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR)\n  const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR)\n  const res = compareDate(d1, d2)\n  if (res === undefined) return undefined\n  return res || compareTime(t1, t2)\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n  /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n  BYTE.lastIndex = 0\n  return BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n  // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n  return Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n  return true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n  if (Z_ANCHOR.test(str)) return false\n  try {\n    new RegExp(str)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import Ajv, { Options } from 'ajv';\nimport addFormats, { FormatsPluginOptions } from 'ajv-formats';\nimport isObject from 'lodash/isObject';\n\nimport { CustomValidatorOptionsType } from './types';\nimport { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITONAL_PROPERTIES_FLAG } from '@rjsf/utils';\n\nexport const AJV_CONFIG: Options = {\n  allErrors: true,\n  multipleOfPrecision: 8,\n  strict: false,\n  verbose: true,\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType['additionalMetaSchemas'],\n  customFormats?: CustomValidatorOptionsType['customFormats'],\n  ajvOptionsOverrides: CustomValidatorOptionsType['ajvOptionsOverrides'] = {},\n  ajvFormatOptions?: FormatsPluginOptions | false,\n  AjvClass: typeof Ajv = Ajv\n) {\n  const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n  if (ajvFormatOptions) {\n    addFormats(ajv, ajvFormatOptions);\n  } else if (ajvFormatOptions !== false) {\n    addFormats(ajv);\n  }\n\n  // add custom formats\n  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);\n  ajv.addFormat('color', COLOR_FORMAT_REGEX);\n\n  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\n  ajv.addKeyword(RJSF_ADDITONAL_PROPERTIES_FLAG);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport {\n  createErrorHandler,\n  CustomValidator,\n  ErrorTransformer,\n  FormContextType,\n  getDefaultFormState,\n  getUiOptions,\n  PROPERTIES_KEY,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  toErrorSchema,\n  UiSchema,\n  unwrapErrorHandler,\n  validationDataMerge,\n  ValidatorType,\n} from '@rjsf/utils';\n\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\n\n/** Transforming the error output from ajv to format used by @rjsf/utils.\n * At some point, components should be updated to support ajv.\n *\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport function transformRJSFValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\n  return errors.map((e: ErrorObject) => {\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\n    let { message = '' } = rest;\n    let property = instancePath.replace(/\\//g, '.');\n    let stack = `${property} ${message}`.trim();\n\n    if ('missingProperty' in params) {\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\n      const currentProperty: string = params.missingProperty;\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        message = message.replace(currentProperty, uiSchemaTitle);\n      } else {\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\n\n        if (parentSchemaTitle) {\n          message = message.replace(currentProperty, parentSchemaTitle);\n        }\n      }\n\n      stack = message;\n    } else {\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\n\n      if (uiSchemaTitle) {\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\n      } else {\n        const parentSchemaTitle = parentSchema?.title;\n\n        if (parentSchemaTitle) {\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\n        }\n      }\n    }\n\n    // put data in expected format\n    return {\n      name: keyword,\n      property,\n      message,\n      params, // specific to ajv\n      stack,\n      schemaPath,\n    };\n  });\n}\n\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n * transform them in what ever way it chooses.\n *\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\n * @param rawErrors - The list of raw `ErrorObject`s to process\n * @param formData - The form data to validate\n * @param schema - The schema against which to validate the form data\n * @param [customValidate] - An optional function that is used to perform custom validation\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n */\nexport default function processRawValidationErrors<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rawErrors: RawValidationErrorsType<ErrorObject>,\n  formData: T | undefined,\n  schema: S,\n  customValidate?: CustomValidator<T, S, F>,\n  transformErrors?: ErrorTransformer<T, S, F>,\n  uiSchema?: UiSchema<T, S, F>\n) {\n  const { validationError: invalidSchemaError } = rawErrors;\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\n\n  if (invalidSchemaError) {\n    errors = [...errors, { stack: invalidSchemaError!.message }];\n  }\n  if (typeof transformErrors === 'function') {\n    errors = transformErrors(errors, uiSchema);\n  }\n\n  let errorSchema = toErrorSchema<T>(errors);\n\n  if (invalidSchemaError) {\n    errorSchema = {\n      ...errorSchema,\n      $schema: {\n        __errors: [invalidSchemaError!.message],\n      },\n    };\n  }\n\n  if (typeof customValidate !== 'function') {\n    return { errors, errorSchema };\n  }\n\n  // Include form data with undefined values, which is required for custom validation.\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\n\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\n}\n","import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  ID_KEY,\n  RJSFSchema,\n  ROOT_SCHEMA_PREFIX,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  withIdRefPrefix,\n  hashForSchema,\n} from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport createAjvInstance from './createAjvInstance';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\n */\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  ajv: Ajv;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   */\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\n    this.localizer = localizer;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    let compilationError: Error | undefined = undefined;\n    let compiledValidator: ValidateFunction | undefined;\n    if (schema[ID_KEY]) {\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\n    }\n    try {\n      if (compiledValidator === undefined) {\n        compiledValidator = this.ajv.compile(schema);\n      }\n      compiledValidator(formData);\n    } catch (err) {\n      compilationError = err as Error;\n    }\n\n    let errors;\n    if (compiledValidator) {\n      if (typeof this.localizer === 'function') {\n        this.localizer(compiledValidator.errors);\n      }\n      errors = compiledValidator.errors || undefined;\n\n      // Clear errors to prevent persistent errors, see #1104\n      compiledValidator.errors = null;\n    }\n\n    return {\n      errors: errors as unknown as Result[],\n      validationError: compilationError,\n    };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    const rootSchemaId = rootSchema[ID_KEY] ?? ROOT_SCHEMA_PREFIX;\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      // if (this.ajv.getSchema(rootSchemaId) === undefined) {\n      // TODO restore the commented out `if` above when the TODO in the `finally` is completed\n      this.ajv.addSchema(rootSchema, rootSchemaId);\n      // }\n      const schemaWithIdRefPrefix = withIdRefPrefix<S>(schema) as S;\n      const schemaId = schemaWithIdRefPrefix[ID_KEY] ?? hashForSchema(schemaWithIdRefPrefix);\n      let compiledValidator: ValidateFunction | undefined;\n      compiledValidator = this.ajv.getSchema(schemaId);\n      if (compiledValidator === undefined) {\n        // Add schema by an explicit ID so it can be fetched later\n        // Fall back to using compile if necessary\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\n        compiledValidator =\n          this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||\n          this.ajv.compile(schemaWithIdRefPrefix);\n      }\n      const result = compiledValidator(formData);\n      return result as boolean;\n    } catch (e) {\n      console.warn('Error encountered compiling schema:', e);\n      return false;\n    } finally {\n      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(rootSchemaId);\n    }\n  }\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema } from '@rjsf/utils';\n\nimport { CustomValidatorOptionsType, Localizer } from './types';\nimport AJV8Validator from './validator';\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV\n * validation.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The custom validator implementation resulting from the set of parameters provided\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(options: CustomValidatorOptionsType = {}, localizer?: Localizer) {\n  return new AJV8Validator<T, S, F>(options, localizer);\n}\n","import { ErrorObject } from 'ajv';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  hashForSchema,\n  ID_KEY,\n  JUNK_OPTION_ID,\n  RJSFSchema,\n  StrictRJSFSchema,\n  toErrorList,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  retrieveSchema,\n} from '@rjsf/utils';\n\nimport { CompiledValidateFunction, Localizer, ValidatorFunctions } from './types';\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\n\n/** `ValidatorType` implementation that uses an AJV 8 precompiled validator as created by the\n * `compileSchemaValidators()` function provided by the `@rjsf/validator-ajv8` library.\n */\nexport default class AJV8PrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> implements ValidatorType<T, S, F>\n{\n  /** The root schema object used to construct this validator\n   *\n   * @private\n   */\n  readonly rootSchema: S;\n\n  /** The `ValidatorFunctions` map used to construct this validator\n   *\n   * @private\n   */\n  readonly validateFns: ValidatorFunctions;\n\n  /** The main validator function associated with the base schema in the `precompiledValidator`\n   *\n   * @private\n   */\n  readonly mainValidator: CompiledValidateFunction;\n\n  /** The Localizer function to use for localizing Ajv errors\n   *\n   * @private\n   */\n  readonly localizer?: Localizer;\n\n  /** Constructs an `AJV8PrecompiledValidator` instance using the `validateFns` and `rootSchema`\n   *\n   * @param validateFns - The map of the validation functions that are generated by the `schemaCompile()` function\n   * @param rootSchema - The root schema that was used with the `compileSchema()` function\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n   * @throws - Error when the base schema of the precompiled validator does not have a matching validator function\n   */\n  constructor(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer) {\n    this.rootSchema = rootSchema;\n    this.validateFns = validateFns;\n    this.localizer = localizer;\n    this.mainValidator = this.getValidator(rootSchema);\n  }\n\n  /** Returns the precompiled validator associated with the given `schema` from the map of precompiled validator\n   * functions.\n   *\n   * @param schema - The schema for which a precompiled validator function is desired\n   * @returns - The precompiled validator function associated with this schema\n   */\n  getValidator(schema: S) {\n    const key = get(schema, ID_KEY) || hashForSchema(schema);\n    const validator = this.validateFns[key];\n    if (!validator) {\n      throw new Error(`No precompiled validator function was found for the given schema for \"${key}\"`);\n    }\n    return validator;\n  }\n\n  /** Ensures that the validator is using the same schema as the root schema used to construct the precompiled\n   * validator. It first compares the given `schema` against the root schema and if they aren't the same, then it\n   * checks against the resolved root schema, on the chance that a resolved version of the root schema was passed in\n   * instead of the raw root schema.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param [formData] - The form data to validate if any\n   */\n  ensureSameRootSchema(schema: S, formData?: T) {\n    if (!isEqual(schema, this.rootSchema)) {\n      // Resolve the root schema with the passed in form data since that may affect the resolution\n      const resolvedRootSchema = retrieveSchema(this, this.rootSchema, this.rootSchema, formData);\n      if (!isEqual(schema, resolvedRootSchema)) {\n        throw new Error(\n          'The schema associated with the precompiled validator differs from the rootSchema provided for validation'\n        );\n      }\n    }\n    return true;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in\n   *        the next major release.\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    return toErrorList(errorSchema, fieldPath);\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param [formData] - The form data to validate, if any\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator\n   */\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\n    this.ensureSameRootSchema(schema, formData);\n    this.mainValidator(formData);\n\n    if (typeof this.localizer === 'function') {\n      this.localizer(this.mainValidator.errors);\n    }\n    const errors = this.mainValidator.errors || undefined;\n\n    // Clear errors to prevent persistent errors, see #1104\n    this.mainValidator.errors = null;\n\n    return { errors: errors as unknown as Result[] };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or false otherwise. If the schema is\n   * invalid, then this function will return false.\n   *\n   * @param schema - The schema against which to validate the form data\n   * @param formData - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   * @returns - true if the formData validates against the schema, false otherwise\n   * @throws - Error when the schema provided does not match the base schema of the precompiled validator OR if there\n   *        isn't a precompiled validator function associated with the schema\n   */\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\n    this.ensureSameRootSchema(rootSchema, formData);\n    if (get(schema, ID_KEY) === JUNK_OPTION_ID) {\n      return false;\n    }\n    const validator = this.getValidator(schema);\n    return validator(formData);\n  }\n}\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '@rjsf/utils';\n\nimport { Localizer, ValidatorFunctions } from './types';\nimport AJV8PrecompiledValidator from './precompiledValidator';\n\n/** Creates and returns a `ValidatorType` interface that is implemented with a precompiled validator. If a `localizer`\n * is provided, it is used to translate the messages generated by the underlying AJV validation.\n *\n * NOTE: The `validateFns` parameter is an object obtained by importing from a precompiled validation file created via\n * the `compileSchemaValidators()` function.\n *\n * @param validateFns - The map of the validation functions that are created by the `compileSchemaValidators()` function\n * @param rootSchema - The root schema that was used with the `compileSchemaValidators()` function\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\n * @returns - The precompiled validator implementation resulting from the set of parameters provided\n */\nexport default function createPrecompiledValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validateFns: ValidatorFunctions, rootSchema: S, localizer?: Localizer): ValidatorType<T, S, F> {\n  return new AJV8PrecompiledValidator<T, S, F>(validateFns, rootSchema, localizer);\n}\n","import customizeValidator from './customizeValidator';\nimport createPrecompiledValidator from './createPrecompiledValidator';\n\nexport { customizeValidator, createPrecompiledValidator };\nexport * from './types';\n\nexport default customizeValidator();\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import {\n  DefinedFormats,\n  FormatMode,\n  FormatName,\n  formatNames,\n  fastFormats,\n  fullFormats,\n} from \"./formats\"\nimport formatLimit from \"./limit\"\nimport type Ajv from \"ajv\"\nimport type {Plugin, Format} from \"ajv\"\nimport {_, Name} from \"ajv/dist/compile/codegen\"\n\nexport {FormatMode, FormatName} from \"./formats\"\nexport {LimitFormatError} from \"./limit\"\nexport interface FormatOptions {\n  mode?: FormatMode\n  formats?: FormatName[]\n  keywords?: boolean\n}\n\nexport type FormatsPluginOptions = FormatName[] | FormatOptions\n\nexport interface FormatsPlugin extends Plugin<FormatsPluginOptions> {\n  get: (format: FormatName, mode?: FormatMode) => Format\n}\n\nconst fullName = new Name(\"fullFormats\")\nconst fastName = new Name(\"fastFormats\")\n\nconst formatsPlugin: FormatsPlugin = (\n  ajv: Ajv,\n  opts: FormatsPluginOptions = {keywords: true}\n): Ajv => {\n  if (Array.isArray(opts)) {\n    addFormats(ajv, opts, fullFormats, fullName)\n    return ajv\n  }\n  const [formats, exportName] =\n    opts.mode === \"fast\" ? [fastFormats, fastName] : [fullFormats, fullName]\n  const list = opts.formats || formatNames\n  addFormats(ajv, list, formats, exportName)\n  if (opts.keywords) formatLimit(ajv)\n  return ajv\n}\n\nformatsPlugin.get = (name: FormatName, mode: FormatMode = \"full\"): Format => {\n  const formats = mode === \"fast\" ? fastFormats : fullFormats\n  const f = formats[name]\n  if (!f) throw new Error(`Unknown format \"${name}\"`)\n  return f\n}\n\nfunction addFormats(ajv: Ajv, list: FormatName[], fs: DefinedFormats, exportName: Name): void {\n  ajv.opts.code.formats ??= _`require(\"ajv-formats/dist/formats\").${exportName}`\n  for (const f of list) ajv.addFormat(f, fs[f])\n}\n\nmodule.exports = exports = formatsPlugin\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default formatsPlugin\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","export function merge(...sets:Array<string>):string {\n\tif (sets.length > 1) {\n\t\tsets[0] = sets[0].slice(0, -1);\n\t\tconst xl = sets.length - 1;\n\t\tfor (let x = 1; x < xl; ++x) {\n\t\t\tsets[x] = sets[x].slice(1, -1);\n\t\t}\n\t\tsets[xl] = sets[xl].slice(1);\n\t\treturn sets.join('');\n\t} else {\n\t\treturn sets[0];\n\t}\n}\n\nexport function subexp(str:string):string {\n\treturn \"(?:\" + str + \")\";\n}\n\nexport function typeOf(o:any):string {\n\treturn o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\n}\n\nexport function toUpperCase(str:string):string {\n\treturn str.toUpperCase();\n}\n\nexport function toArray(obj:any):Array<any> {\n\treturn obj !== undefined && obj !== null ? (obj instanceof Array ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\n}\n\n\nexport function assign(target: object, source: any): any {\n\tconst obj = target as any;\n\tif (source) {\n\t\tfor (const key in source) {\n\t\t\tobj[key] = source[key];\n\t\t}\n\t}\n\treturn obj;\n}","import { URIRegExps } from \"./uri\";\nimport { merge, subexp } from \"./util\";\n\nexport function buildExps(isIRI:boolean):URIRegExps {\n\tconst\n\t\tALPHA$$ = \"[A-Za-z]\",\n\t\tCR$ = \"[\\\\x0D]\",\n\t\tDIGIT$$ = \"[0-9]\",\n\t\tDQUOTE$$ = \"[\\\\x22]\",\n\t\tHEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),  //case-insensitive\n\t\tLF$$ = \"[\\\\x0A]\",\n\t\tSP$$ = \"[\\\\x20]\",\n\t\tPCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),  //expanded\n\t\tGEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n\t\tSUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n\t\tRESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n\t\tUCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",  //subset, excludes bidi control characters\n\t\tIPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",  //subset\n\t\tUNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n\t\tSCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n\t\tUSERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n\t\tDEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n\t\tDEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),  //relaxed parsing rules\n\t\tIPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n\t\tH16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n\t\tLS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n\t\tIPV6ADDRESS1$ = subexp(                                                            subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n\t\tIPV6ADDRESS2$ = subexp(                                                 \"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n\t\tIPV6ADDRESS3$ = subexp(subexp(                                 H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n\t\tIPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n\t\tIPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n\t\tIPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" +        H16$ + \"\\\\:\"          + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n\t\tIPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\"                                + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n\t\tIPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\"                                + H16$ ), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n\t\tIPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"                                       ), //[ *6( h16 \":\" ) h16 ] \"::\"\n\t\tIPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n\t\tZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),  //RFC 6874\n\t\tIPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),  //RFC 6874\n\t\tIPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),  //RFC 6874, with relaxed parsing rules\n\t\tIPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n\t\tIP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),  //RFC 6874\n\t\tREG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n\t\tHOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n\t\tPORT$ = subexp(DIGIT$$ + \"*\"),\n\t\tAUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n\t\tPCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n\t\tSEGMENT$ = subexp(PCHAR$ + \"*\"),\n\t\tSEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n\t\tSEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n\t\tPATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n\t\tPATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),  //simplified\n\t\tPATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),  //simplified\n\t\tPATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n\t\tPATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tQUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n\t\tFRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n\t\tHIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n\t\tURI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tRELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n\t\tRELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n\t\tURI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n\t\tABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n\n\t\tGENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tRELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n\t\tSAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n\t\tAUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\"\n\t;\n\n\treturn {\n\t\tNOT_SCHEME : new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n\t\tNOT_USERINFO : new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_HOST : new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH : new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_PATH_NOSCHEME : new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tNOT_QUERY : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n\t\tNOT_FRAGMENT : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n\t\tESCAPE : new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n\t\tUNRESERVED : new RegExp(UNRESERVED$$, \"g\"),\n\t\tOTHER_CHARS : new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n\t\tPCT_ENCODED : new RegExp(PCT_ENCODED$, \"g\"),\n\t\tIPV4ADDRESS : new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n\t\tIPV6ADDRESS : new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")  //RFC 6874, with relaxed parsing rules\n\t};\n}\n\nexport default buildExps(false);\n","import { URIRegExps } from \"./uri\";\nimport { buildExps } from \"./regexps-uri\";\n\nexport default buildExps(true);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport default punycode;\n","/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\n\nimport URI_PROTOCOL from \"./regexps-uri\";\nimport IRI_PROTOCOL from \"./regexps-iri\";\nimport punycode from \"punycode\";\nimport { toUpperCase, typeOf, assign } from \"./util\";\n\nexport interface URIComponents {\n\tscheme?:string;\n\tuserinfo?:string;\n\thost?:string;\n\tport?:number|string;\n\tpath?:string;\n\tquery?:string;\n\tfragment?:string;\n\treference?:string;\n\terror?:string;\n}\n\nexport interface URIOptions {\n\tscheme?:string;\n\treference?:string;\n\ttolerant?:boolean;\n\tabsolutePath?:boolean;\n\tiri?:boolean;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n}\n\nexport interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> {\n\tscheme:string;\n\tparse(components:ParentComponents, options:Options):Components;\n\tserialize(components:Components, options:Options):ParentComponents;\n\tunicodeSupport?:boolean;\n\tdomainHost?:boolean;\n\tabsolutePath?:boolean;\n}\n\nexport interface URIRegExps {\n\tNOT_SCHEME : RegExp,\n\tNOT_USERINFO : RegExp,\n\tNOT_HOST : RegExp,\n\tNOT_PATH : RegExp,\n\tNOT_PATH_NOSCHEME : RegExp,\n\tNOT_QUERY : RegExp,\n\tNOT_FRAGMENT : RegExp,\n\tESCAPE : RegExp,\n\tUNRESERVED : RegExp,\n\tOTHER_CHARS : RegExp,\n\tPCT_ENCODED : RegExp,\n\tIPV4ADDRESS : RegExp,\n\tIPV6ADDRESS : RegExp,\n}\n\nexport const SCHEMES:{[scheme:string]:URISchemeHandler} = {};\n\nexport function pctEncChar(chr:string):string {\n\tconst c = chr.charCodeAt(0);\n\tlet e:string;\n\n\tif (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n\telse if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n\telse if (c < 2048) e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\telse e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\n\n\treturn e;\n}\n\nexport function pctDecChars(str:string):string {\n\tlet newStr = \"\";\n\tlet i = 0;\n\tconst il = str.length;\n\n\twhile (i < il) {\n\t\tconst c = parseInt(str.substr(i + 1, 2), 16);\n\n\t\tif (c < 128) {\n\t\t\tnewStr += String.fromCharCode(c);\n\t\t\ti += 3;\n\t\t}\n\t\telse if (c >= 194 && c < 224) {\n\t\t\tif ((il - i) >= 6) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 6);\n\t\t\t}\n\t\t\ti += 6;\n\t\t}\n\t\telse if (c >= 224) {\n\t\t\tif ((il - i) >= 9) {\n\t\t\t\tconst c2 = parseInt(str.substr(i + 4, 2), 16);\n\t\t\t\tconst c3 = parseInt(str.substr(i + 7, 2), 16);\n\t\t\t\tnewStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n\t\t\t} else {\n\t\t\t\tnewStr += str.substr(i, 9);\n\t\t\t}\n\t\t\ti += 9;\n\t\t}\n\t\telse {\n\t\t\tnewStr += str.substr(i, 3);\n\t\t\ti += 3;\n\t\t}\n\t}\n\n\treturn newStr;\n}\n\nfunction _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) {\n\tfunction decodeUnreserved(str:string):string {\n\t\tconst decStr = pctDecChars(str);\n\t\treturn (!decStr.match(protocol.UNRESERVED) ? str : decStr);\n\t}\n\n\tif (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n\tif (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\tif (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n\n\treturn components;\n};\n\nfunction _stripLeadingZeros(str:string):string {\n\treturn str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\n\nfunction _normalizeIPv4(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV4ADDRESS) || [];\n\tconst [, address] = matches;\n\t\n\tif (address) {\n\t\treturn address.split(\".\").map(_stripLeadingZeros).join(\".\");\n\t} else {\n\t\treturn host;\n\t}\n}\n\nfunction _normalizeIPv6(host:string, protocol:URIRegExps):string {\n\tconst matches = host.match(protocol.IPV6ADDRESS) || [];\n\tconst [, address, zone] = matches;\n\n\tif (address) {\n\t\tconst [last, first] = address.toLowerCase().split('::').reverse();\n\t\tconst firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n\t\tconst lastFields = last.split(\":\").map(_stripLeadingZeros);\n\t\tconst isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n\t\tconst fieldCount = isLastFieldIPv4Address ? 7 : 8;\n\t\tconst lastFieldsStart = lastFields.length - fieldCount;\n\t\tconst fields = Array<string>(fieldCount);\n\n\t\tfor (let x = 0; x < fieldCount; ++x) {\n\t\t\tfields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n\t\t}\n\n\t\tif (isLastFieldIPv4Address) {\n\t\t\tfields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n\t\t}\n\n\t\tconst allZeroFields = fields.reduce<Array<{index:number,length:number}>>((acc, field, index) => {\n\t\t\tif (!field || field === \"0\") {\n\t\t\t\tconst lastLongest = acc[acc.length - 1];\n\t\t\t\tif (lastLongest && lastLongest.index + lastLongest.length === index) {\n\t\t\t\t\tlastLongest.length++;\n\t\t\t\t} else {\n\t\t\t\t\tacc.push({ index, length : 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];\n\n\t\tlet newHost:string;\n\t\tif (longestZeroFields && longestZeroFields.length > 1) {\n\t\t\tconst newFirst = fields.slice(0, longestZeroFields.index) ;\n\t\t\tconst newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n\t\t\tnewHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n\t\t} else {\n\t\t\tnewHost = fields.join(\":\");\n\t\t}\n\n\t\tif (zone) {\n\t\t\tnewHost += \"%\" + zone;\n\t\t}\n\n\t\treturn newHost;\n\t} else {\n\t\treturn host;\n\t}\n}\n\nconst URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nconst NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>(\"\").match(/(){0}/))[1] === undefined;\n\nexport function parse(uriString:string, options:URIOptions = {}):URIComponents {\n\tconst components:URIComponents = {};\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\n\tif (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n\n\tconst matches = uriString.match(URI_PARSE);\n\n\tif (matches) {\n\t\tif (NO_MATCH_IS_UNDEFINED) {\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1];\n\t\t\tcomponents.userinfo = matches[3];\n\t\t\tcomponents.host = matches[4];\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = matches[7];\n\t\t\tcomponents.fragment = matches[8];\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = matches[5];\n\t\t\t}\n\t\t} else {  //IE FIX for improper RegExp matching\n\t\t\t//store each component\n\t\t\tcomponents.scheme = matches[1] || undefined;\n\t\t\tcomponents.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\n\t\t\tcomponents.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\n\t\t\tcomponents.port = parseInt(matches[5], 10);\n\t\t\tcomponents.path = matches[6] || \"\";\n\t\t\tcomponents.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\n\t\t\tcomponents.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\n\n\t\t\t//fix port number\n\t\t\tif (isNaN(components.port)) {\n\t\t\t\tcomponents.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\n\t\t\t}\n\t\t}\n\n\t\tif (components.host) {\n\t\t\t//normalize IP hosts\n\t\t\tcomponents.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n\t\t}\n\n\t\t//determine reference type\n\t\tif (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n\t\t\tcomponents.reference = \"same-document\";\n\t\t} else if (components.scheme === undefined) {\n\t\t\tcomponents.reference = \"relative\";\n\t\t} else if (components.fragment === undefined) {\n\t\t\tcomponents.reference = \"absolute\";\n\t\t} else {\n\t\t\tcomponents.reference = \"uri\";\n\t\t}\n\n\t\t//check for reference errors\n\t\tif (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n\t\t\tcomponents.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n\t\t}\n\n\t\t//find scheme handler\n\t\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t\t//check if scheme can't handle IRIs\n\t\tif (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n\t\t\t//if host component is a domain name\n\t\t\tif (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\tcomponents.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//convert IRI -> URI\n\t\t\t_normalizeComponentEncoding(components, URI_PROTOCOL);\n\t\t} else {\n\t\t\t//normalize encodings\n\t\t\t_normalizeComponentEncoding(components, protocol);\n\t\t}\n\n\t\t//perform scheme specific parsing\n\t\tif (schemeHandler && schemeHandler.parse) {\n\t\t\tschemeHandler.parse(components, options);\n\t\t}\n\t} else {\n\t\tcomponents.error = components.error || \"URI can not be parsed.\";\n\t}\n\n\treturn components;\n};\n\nfunction _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined {\n\tconst protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\tif (components.userinfo !== undefined) {\n\t\turiTokens.push(components.userinfo);\n\t\turiTokens.push(\"@\");\n\t}\n\n\tif (components.host !== undefined) {\n\t\t//normalize IP hosts, add brackets and escape zone separator for IPv6\n\t\turiTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\"));\n\t}\n\n\tif (typeof components.port === \"number\" || typeof components.port === \"string\") {\n\t\turiTokens.push(\":\");\n\t\turiTokens.push(String(components.port));\n\t}\n\n\treturn uriTokens.length ? uriTokens.join(\"\") : undefined;\n};\n\nconst RDS1 = /^\\.\\.?\\//;\nconst RDS2 = /^\\/\\.(\\/|$)/;\nconst RDS3 = /^\\/\\.\\.(\\/|$)/;\nconst RDS4 = /^\\.\\.?$/;\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n\nexport function removeDotSegments(input:string):string {\n\tconst output:Array<string> = [];\n\n\twhile (input.length) {\n\t\tif (input.match(RDS1)) {\n\t\t\tinput = input.replace(RDS1, \"\");\n\t\t} else if (input.match(RDS2)) {\n\t\t\tinput = input.replace(RDS2, \"/\");\n\t\t} else if (input.match(RDS3)) {\n\t\t\tinput = input.replace(RDS3, \"/\");\n\t\t\toutput.pop();\n\t\t} else if (input === \".\" || input === \"..\") {\n\t\t\tinput = \"\";\n\t\t} else {\n\t\t\tconst im = input.match(RDS5);\n\t\t\tif (im) {\n\t\t\t\tconst s = im[0];\n\t\t\t\tinput = input.slice(s.length);\n\t\t\t\toutput.push(s);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unexpected dot segment condition\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn output.join(\"\");\n};\n\nexport function serialize(components:URIComponents, options:URIOptions = {}):string {\n\tconst protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);\n\tconst uriTokens:Array<string> = [];\n\n\t//find scheme handler\n\tconst schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n\n\t//perform scheme specific serialization\n\tif (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n\n\tif (components.host) {\n\t\t//if host component is an IPv6 address\n\t\tif (protocol.IPV6ADDRESS.test(components.host)) {\n\t\t\t//TODO: normalize IPv6 address as per RFC 5952\n\t\t}\n\n\t\t//if host component is a domain name\n\t\telse if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {\n\t\t\t//convert IDN via punycode\n\t\t\ttry {\n\t\t\t\tcomponents.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\n\t\t\t} catch (e) {\n\t\t\t\tcomponents.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//normalize encoding\n\t_normalizeComponentEncoding(components, protocol);\n\n\tif (options.reference !== \"suffix\" && components.scheme) {\n\t\turiTokens.push(components.scheme);\n\t\turiTokens.push(\":\");\n\t}\n\n\tconst authority = _recomposeAuthority(components, options);\n\tif (authority !== undefined) {\n\t\tif (options.reference !== \"suffix\") {\n\t\t\turiTokens.push(\"//\");\n\t\t}\n\n\t\turiTokens.push(authority);\n\n\t\tif (components.path && components.path.charAt(0) !== \"/\") {\n\t\t\turiTokens.push(\"/\");\n\t\t}\n\t}\n\n\tif (components.path !== undefined) {\n\t\tlet s = components.path;\n\n\t\tif (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n\t\t\ts = removeDotSegments(s);\n\t\t}\n\n\t\tif (authority === undefined) {\n\t\t\ts = s.replace(/^\\/\\//, \"/%2F\");  //don't allow the path to start with \"//\"\n\t\t}\n\n\t\turiTokens.push(s);\n\t}\n\n\tif (components.query !== undefined) {\n\t\turiTokens.push(\"?\");\n\t\turiTokens.push(components.query);\n\t}\n\n\tif (components.fragment !== undefined) {\n\t\turiTokens.push(\"#\");\n\t\turiTokens.push(components.fragment);\n\t}\n\n\treturn uriTokens.join(\"\");  //merge tokens into a string\n};\n\nexport function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = {}, skipNormalization?:boolean):URIComponents {\n\tconst target:URIComponents = {};\n\n\tif (!skipNormalization) {\n\t\tbase = parse(serialize(base, options), options);  //normalize base components\n\t\trelative = parse(serialize(relative, options), options);  //normalize relative components\n\t}\n\toptions = options || {};\n\n\tif (!options.tolerant && relative.scheme) {\n\t\ttarget.scheme = relative.scheme;\n\t\t//target.authority = relative.authority;\n\t\ttarget.userinfo = relative.userinfo;\n\t\ttarget.host = relative.host;\n\t\ttarget.port = relative.port;\n\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\ttarget.query = relative.query;\n\t} else {\n\t\tif (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n\t\t\t//target.authority = relative.authority;\n\t\t\ttarget.userinfo = relative.userinfo;\n\t\t\ttarget.host = relative.host;\n\t\t\ttarget.port = relative.port;\n\t\t\ttarget.path = removeDotSegments(relative.path || \"\");\n\t\t\ttarget.query = relative.query;\n\t\t} else {\n\t\t\tif (!relative.path) {\n\t\t\t\ttarget.path = base.path;\n\t\t\t\tif (relative.query !== undefined) {\n\t\t\t\t\ttarget.query = relative.query;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.query = base.query;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (relative.path.charAt(0) === \"/\") {\n\t\t\t\t\ttarget.path = removeDotSegments(relative.path);\n\t\t\t\t} else {\n\t\t\t\t\tif ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n\t\t\t\t\t\ttarget.path = \"/\" + relative.path;\n\t\t\t\t\t} else if (!base.path) {\n\t\t\t\t\t\ttarget.path = relative.path;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n\t\t\t\t\t}\n\t\t\t\t\ttarget.path = removeDotSegments(target.path);\n\t\t\t\t}\n\t\t\t\ttarget.query = relative.query;\n\t\t\t}\n\t\t\t//target.authority = base.authority;\n\t\t\ttarget.userinfo = base.userinfo;\n\t\t\ttarget.host = base.host;\n\t\t\ttarget.port = base.port;\n\t\t}\n\t\ttarget.scheme = base.scheme;\n\t}\n\n\ttarget.fragment = relative.fragment;\n\n\treturn target;\n};\n\nexport function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string {\n\tconst schemelessOptions = assign({ scheme : 'null' }, options);\n\treturn serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n};\n\nexport function normalize(uri:string, options?:URIOptions):string;\nexport function normalize(uri:URIComponents, options?:URIOptions):URIComponents;\nexport function normalize(uri:any, options?:URIOptions):any {\n\tif (typeof uri === \"string\") {\n\t\turi = serialize(parse(uri, options), options);\n\t} else if (typeOf(uri) === \"object\") {\n\t\turi = parse(serialize(<URIComponents>uri, options), options);\n\t}\n\n\treturn uri;\n};\n\nexport function equal(uriA:string, uriB:string, options?: URIOptions):boolean;\nexport function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;\nexport function equal(uriA:any, uriB:any, options?:URIOptions):boolean {\n\tif (typeof uriA === \"string\") {\n\t\turiA = serialize(parse(uriA, options), options);\n\t} else if (typeOf(uriA) === \"object\") {\n\t\turiA = serialize(<URIComponents>uriA, options);\n\t}\n\n\tif (typeof uriB === \"string\") {\n\t\turiB = serialize(parse(uriB, options), options);\n\t} else if (typeOf(uriB) === \"object\") {\n\t\turiB = serialize(<URIComponents>uriB, options);\n\t}\n\n\treturn uriA === uriB;\n};\n\nexport function escapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\n};\n\nexport function unescapeComponent(str:string, options?:URIOptions):string {\n\treturn str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\n};\n","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"http\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\t//report missing host\n\t\tif (!components.host) {\n\t\t\tcomponents.error = components.error || \"HTTP URIs must have a host.\";\n\t\t}\n\n\t\treturn components;\n\t},\n\n\tserialize : function (components:URIComponents, options:URIOptions):URIComponents {\n\t\tconst secure = String(components.scheme).toLowerCase() === \"https\";\n\n\t\t//normalize the default port\n\t\tif (components.port === (secure ? 443 : 80) || components.port === \"\") {\n\t\t\tcomponents.port = undefined;\n\t\t}\n\t\t\n\t\t//normalize the empty path\n\t\tif (!components.path) {\n\t\t\tcomponents.path = \"/\";\n\t\t}\n\n\t\t//NOTE: We do not parse query strings for HTTP URIs\n\t\t//as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n\t\t//and not the HTTP spec.\n\n\t\treturn components;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport http from \"./http\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"https\",\n\tdomainHost : http.domainHost,\n\tparse : http.parse,\n\tserialize : http.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\n\nexport interface WSComponents extends URIComponents {\n\tresourceName?: string;\n\tsecure?: boolean;\n}\n\nfunction isSecure(wsComponents:WSComponents):boolean {\n\treturn typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n\n//RFC 6455\nconst handler:URISchemeHandler = {\n\tscheme : \"ws\",\n\n\tdomainHost : true,\n\n\tparse : function (components:URIComponents, options:URIOptions):WSComponents {\n\t\tconst wsComponents = components as WSComponents;\n\n\t\t//indicate if the secure flag is set\n\t\twsComponents.secure = isSecure(wsComponents);\n\n\t\t//construct resouce name\n\t\twsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n\t\twsComponents.path = undefined;\n\t\twsComponents.query = undefined;\n\n\t\treturn wsComponents;\n\t},\n\n\tserialize : function (wsComponents:WSComponents, options:URIOptions):URIComponents {\n\t\t//normalize the default port\n\t\tif (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n\t\t\twsComponents.port = undefined;\n\t\t}\n\n\t\t//ensure scheme matches secure flag\n\t\tif (typeof wsComponents.secure === 'boolean') {\n\t\t\twsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');\n\t\t\twsComponents.secure = undefined;\n\t\t}\n\n\t\t//reconstruct path from resource name\n\t\tif (wsComponents.resourceName) {\n\t\t\tconst [path, query] = wsComponents.resourceName.split('?');\n\t\t\twsComponents.path = (path && path !== '/' ? path : undefined);\n\t\t\twsComponents.query = query;\n\t\t\twsComponents.resourceName = undefined;\n\t\t}\n\n\t\t//forbid fragment component\n\t\twsComponents.fragment = undefined;\n\n\t\treturn wsComponents;\n\t}\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport ws from \"./ws\";\n\nconst handler:URISchemeHandler = {\n\tscheme : \"wss\",\n\tdomainHost : ws.domainHost,\n\tparse : ws.parse,\n\tserialize : ws.serialize\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, pctDecChars, unescapeComponent } from \"../uri\";\nimport punycode from \"punycode\";\nimport { merge, subexp, toUpperCase, toArray } from \"../util\";\n\nexport interface MailtoHeaders {\n\t[hfname:string]:string\n}\n\nexport interface MailtoComponents extends URIComponents {\n\tto:Array<string>,\n\theaders?:MailtoHeaders,\n\tsubject?:string,\n\tbody?:string\n}\n\nconst O:MailtoHeaders = {};\nconst isIRI = true;\n\n//RFC 3986\nconst UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nconst HEXDIG$$ = \"[0-9A-Fa-f]\";  //case-insensitive\nconst PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));  //expanded\n\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nconst ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nconst QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nconst VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nconst DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\");\nconst QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$);\nconst QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$);\nconst QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"');\n\n//RFC 6068\nconst DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\";  //%d33-90 / %d94-126\nconst SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nconst QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$);\nconst DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\");\nconst LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$);\nconst ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$);\nconst TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\");\nconst HFNAME$ = subexp(QCHAR$ + \"*\");\nconst HFVALUE$ = HFNAME$;\nconst HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$);\nconst HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\");\nconst HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$);\nconst MAILTO_URI = new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\");\n\nconst UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nconst PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nconst NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nconst NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\");\nconst NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nconst NOT_HFVALUE = NOT_HFNAME;\nconst TO = new RegExp(\"^\" + TO$ + \"$\");\nconst HFIELDS = new RegExp(\"^\" + HFIELDS2$ + \"$\");\n\nfunction decodeUnreserved(str:string):string {\n\tconst decStr = pctDecChars(str);\n\treturn (!decStr.match(UNRESERVED) ? str : decStr);\n}\n\nconst handler:URISchemeHandler<MailtoComponents> =  {\n\tscheme : \"mailto\",\n\n\tparse : function (components:URIComponents, options:URIOptions):MailtoComponents {\n\t\tconst mailtoComponents = components as MailtoComponents;\n\t\tconst to = mailtoComponents.to = (mailtoComponents.path ? mailtoComponents.path.split(\",\") : []);\n\t\tmailtoComponents.path = undefined;\n\n\t\tif (mailtoComponents.query) {\n\t\t\tlet unknownHeaders = false\n\t\t\tconst headers:MailtoHeaders = {};\n\t\t\tconst hfields = mailtoComponents.query.split(\"&\");\n\n\t\t\tfor (let x = 0, xl = hfields.length; x < xl; ++x) {\n\t\t\t\tconst hfield = hfields[x].split(\"=\");\n\n\t\t\t\tswitch (hfield[0]) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tconst toAddrs = hfield[1].split(\",\");\n\t\t\t\t\t\tfor (let x = 0, xl = toAddrs.length; x < xl; ++x) {\n\t\t\t\t\t\t\tto.push(toAddrs[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"subject\":\n\t\t\t\t\t\tmailtoComponents.subject = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"body\":\n\t\t\t\t\t\tmailtoComponents.body = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tunknownHeaders = true;\n\t\t\t\t\t\theaders[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (unknownHeaders) mailtoComponents.headers = headers;\n\t\t}\n\n\t\tmailtoComponents.query = undefined;\n\n\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\tconst addr = to[x].split(\"@\");\n\n\t\t\taddr[0] = unescapeComponent(addr[0]);\n\n\t\t\tif (!options.unicodeSupport) {\n\t\t\t\t//convert Unicode IDN -> ASCII IDN\n\t\t\t\ttry {\n\t\t\t\t\taddr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n\t\t\t\t} catch (e) {\n\t\t\t\t\tmailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taddr[1] = unescapeComponent(addr[1], options).toLowerCase();\n\t\t\t}\n\n\t\t\tto[x] = addr.join(\"@\");\n\t\t}\n\n\t\treturn mailtoComponents;\n\t},\n\n\tserialize : function (mailtoComponents:MailtoComponents, options:URIOptions):URIComponents {\n\t\tconst components = mailtoComponents as URIComponents;\n\t\tconst to = toArray(mailtoComponents.to);\n\t\tif (to) {\n\t\t\tfor (let x = 0, xl = to.length; x < xl; ++x) {\n\t\t\t\tconst toAddr = String(to[x]);\n\t\t\t\tconst atIdx = toAddr.lastIndexOf(\"@\");\n\t\t\t\tconst localPart = (toAddr.slice(0, atIdx)).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n\t\t\t\tlet domain = toAddr.slice(atIdx + 1);\n\n\t\t\t\t//convert IDN via punycode\n\t\t\t\ttry {\n\t\t\t\t\tdomain = (!options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcomponents.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n\t\t\t\t}\n\n\t\t\t\tto[x] = localPart + \"@\" + domain;\n\t\t\t}\n\n\t\t\tcomponents.path = to.join(\",\");\n\t\t}\n\n\t\tconst headers = mailtoComponents.headers = mailtoComponents.headers || {};\n\n\t\tif (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n\t\tif (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n\n\t\tconst fields = [];\n\t\tfor (const name in headers) {\n\t\t\tif (headers[name] !== O[name]) {\n\t\t\t\tfields.push(\n\t\t\t\t\tname.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) +\n\t\t\t\t\t\"=\" +\n\t\t\t\t\theaders[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (fields.length) {\n\t\t\tcomponents.query = fields.join(\"&\");\n\t\t}\n\n\t\treturn components;\n\t}\n}\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { pctEncChar, SCHEMES } from \"../uri\";\n\nexport interface URNComponents extends URIComponents {\n\tnid?:string;\n\tnss?:string;\n}\n\nexport interface URNOptions extends URIOptions {\n\tnid?:string;\n}\n\nconst NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\";\nconst PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\";\nconst TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\";\nconst NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\";\nconst URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\");\nconst URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\");\nconst URN_PARSE = /^([^\\:]+)\\:(.*)/;\nconst URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g;\n\n//RFC 2141\nconst handler:URISchemeHandler<URNComponents,URNOptions> = {\n\tscheme : \"urn\",\n\n\tparse : function (components:URIComponents, options:URNOptions):URNComponents {\n\t\tconst matches = components.path && components.path.match(URN_PARSE);\n\t\tlet urnComponents = components as URNComponents;\n\n\t\tif (matches) {\n\t\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\t\tconst nid = matches[1].toLowerCase();\n\t\t\tconst nss = matches[2];\n\t\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\t\turnComponents.nid = nid;\n\t\t\turnComponents.nss = nss;\n\t\t\turnComponents.path = undefined;\n\n\t\t\tif (schemeHandler) {\n\t\t\t\turnComponents = schemeHandler.parse(urnComponents, options) as URNComponents;\n\t\t\t}\n\t\t} else {\n\t\t\turnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n\t\t}\n\n\t\treturn urnComponents;\n\t},\n\n\tserialize : function (urnComponents:URNComponents, options:URNOptions):URIComponents {\n\t\tconst scheme = options.scheme || urnComponents.scheme || \"urn\";\n\t\tconst nid = urnComponents.nid;\n\t\tconst urnScheme = `${scheme}:${options.nid || nid}`;\n\t\tconst schemeHandler = SCHEMES[urnScheme];\n\n\t\tif (schemeHandler) {\n\t\t\turnComponents = schemeHandler.serialize(urnComponents, options) as URNComponents;\n\t\t}\n\n\t\tconst uriComponents = urnComponents as URIComponents;\n\t\tconst nss = urnComponents.nss;\n\t\turiComponents.path = `${nid || options.nid}:${nss}`;\n\n\t\treturn uriComponents;\n\t},\n};\n\nexport default handler;","import { URISchemeHandler, URIComponents, URIOptions } from \"../uri\";\nimport { URNComponents } from \"./urn\";\nimport { SCHEMES } from \"../uri\";\n\nexport interface UUIDComponents extends URNComponents {\n\tuuid?: string;\n}\n\nconst UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\nconst UUID_PARSE = /^[0-9A-Fa-f\\-]{36}/;\n\n//RFC 4122\nconst handler:URISchemeHandler<UUIDComponents, URIOptions, URNComponents> = {\n\tscheme : \"urn:uuid\",\n\n\tparse : function (urnComponents:URNComponents, options:URIOptions):UUIDComponents {\n\t\tconst uuidComponents = urnComponents as UUIDComponents;\n\t\tuuidComponents.uuid = uuidComponents.nss;\n\t\tuuidComponents.nss = undefined;\n\n\t\tif (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n\t\t\tuuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n\t\t}\n\n\t\treturn uuidComponents;\n\t},\n\n\tserialize : function (uuidComponents:UUIDComponents, options:URIOptions):URNComponents {\n\t\tconst urnComponents = uuidComponents as URNComponents;\n\t\t//normalize UUID\n\t\turnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n\t\treturn urnComponents;\n\t},\n};\n\nexport default handler;","import { SCHEMES } from \"./uri\";\n\nimport http from \"./schemes/http\";\nSCHEMES[http.scheme] = http;\n\nimport https from \"./schemes/https\";\nSCHEMES[https.scheme] = https;\n\nimport ws from \"./schemes/ws\";\nSCHEMES[ws.scheme] = ws;\n\nimport wss from \"./schemes/wss\";\nSCHEMES[wss.scheme] = wss;\n\nimport mailto from \"./schemes/mailto\";\nSCHEMES[mailto.scheme] = mailto;\n\nimport urn from \"./schemes/urn\";\nSCHEMES[urn.scheme] = urn;\n\nimport uuid from \"./schemes/urn-uuid\";\nSCHEMES[uuid.scheme] = uuid;\n\nexport * from \"./uri\";\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch?.$ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","import * as uri from \"uri-js\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","export abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type Ajv from \"ajv\"\nimport type {\n  Plugin,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  Code,\n  Name,\n  ErrorObject,\n} from \"ajv\"\nimport type {AddedFormat} from \"ajv/dist/types\"\nimport type {Rule} from \"ajv/dist/compile/rules\"\nimport {KeywordCxt} from \"ajv\"\nimport {_, str, or, getProperty, operators} from \"ajv/dist/compile/codegen\"\n\ntype Kwd = \"formatMaximum\" | \"formatMinimum\" | \"formatExclusiveMaximum\" | \"formatExclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst ops = operators\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  formatMaximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  formatMinimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  formatExclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  formatExclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitFormatError = ErrorObject<Kwd, {limit: string; comparison: Comparison}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`should be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nexport const formatLimitDefinition: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {gen, data, schemaCode, keyword, it} = cxt\n    const {opts, self} = it\n    if (!opts.validateFormats) return\n\n    const fCxt = new KeywordCxt(it, (self.RULES.all.format as Rule).definition, \"format\")\n    if (fCxt.$data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fmt = gen.const(\"fmt\", _`${fmts}[${fCxt.schemaCode}]`)\n      cxt.fail$data(\n        or(\n          _`typeof ${fmt} != \"object\"`,\n          _`${fmt} instanceof RegExp`,\n          _`typeof ${fmt}.compare != \"function\"`,\n          compareCode(fmt)\n        )\n      )\n    }\n\n    function validateFormat(): void {\n      const format = fCxt.schema as string\n      const fmtDef: AddedFormat | undefined = self.formats[format]\n      if (!fmtDef || fmtDef === true) return\n      if (\n        typeof fmtDef != \"object\" ||\n        fmtDef instanceof RegExp ||\n        typeof fmtDef.compare != \"function\"\n      ) {\n        throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`)\n      }\n      const fmt = gen.scopeValue(\"formats\", {\n        key: format,\n        ref: fmtDef,\n        code: opts.code.formats ? _`${opts.code.formats}${getProperty(format)}` : undefined,\n      })\n\n      cxt.fail$data(compareCode(fmt))\n    }\n\n    function compareCode(fmt: Name): Code {\n      return _`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword as Kwd].fail} 0`\n    }\n  },\n  dependencies: [\"format\"],\n}\n\nconst formatLimitPlugin: Plugin<undefined> = (ajv: Ajv): Ajv => {\n  ajv.addKeyword(formatLimitDefinition)\n  return ajv\n}\n\nexport default formatLimitPlugin\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n"],"names":["ucs2length","str","len","length","value","pos","charCodeAt","code","def","keyword","type","schemaType","error","message","params","_","propertyName","cxt","gen","schema","data","it","alwaysValidSchema","valid","name","forIn","key","setParams","subschema","dataTypes","compositeRule","if","not","allErrors","break","ok","Error","$data","schemaCode","useLoop","opts","loopEnum","eql","getEql","useFunc","let","block$data","assign","forOf","v","Array","isArray","vSchema","const","or","map","_x","i","sch","equalCode","pass","$ref","baseId","schemaEnv","env","validateName","self","root","callRef","$async","rootName","scopeValue","ref","callRootRef","schOrEnv","resolveRef","call","undefined","uriResolver","SchemaEnv","getValidate","callValidate","schName","source","stringify","schCxt","schemaPath","nil","topSchemaRef","errSchemaPath","mergeEvaluated","inlineRefSchema","validate","passCxt","passContext","this","addErrorsFrom","errs","vErrors","errors","addEvaluatedFrom","unevaluated","schEvaluated","evaluated","props","dynamicProps","var","Name","items","dynamicItems","try","callValidateCode","e","ValidationError","throw","callAsyncRef","result","DataType","getJSONTypes","ts","types","every","isJSONType","join","includes","nullable","push","coerceTo","coerceTypes","filter","t","COERCIBLE","has","coerceToTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","dataType","coerced","coerceSpecificType","elseIf","else","reportTypeError","endIf","parentData","parentDataProperty","expr","assignParentData","coerceData","Set","checkDataType","strictNums","correct","Correct","EQ","operators","NEQ","cond","numCond","_cond","and","toHash","array","object","notObj","null","number","integer","typeError","schemaValue","schemaRefOrVal","parentSchema","getTypeErrorContext","reportError","allowUndefined","trackErrors","additionalProperty","errsCount","removeAdditional","allSchemaProperties","properties","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","reset","dataProp","dataPropType","Type","Str","Object","createErrors","definedProp","propsSchema","isOwnProperty","p","usePattern","isAdditional","j","itemTypes","getSchemaTypes","loopN","item","indices","for","loopN2","outer","label","some","comp","op","GT","LT","unicode","fail$data","fail","failResult","jsonTypes","x","groups","rules","string","boolean","post","all","keywords","module","exports","equal","a","b","constructor","keys","RegExp","flags","valueOf","prototype","toString","hasOwnProperty","metadataVocabulary","contentVocabulary","validateFunction","body","es5","func","valCxt","funcSourceUrl","instancePath","rootData","dynamicRef","dynamicAnchors","destructureValCxtES5","destructureValCxt","schId","schemaId","process","schemaCxtHasRules","RULES","isSchemaObj","checkKeywords","checkUnknownRules","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","checkRefsAndKeywords","typeAndKeywords","jtd","schemaKeywords","coerceAndCheckDataType","commentKeyword","msg","$comment","typeErrors","groupKeywords","group","shouldUseGroup","iterateKeywords","meta","strictTypes","forEach","includesType","strictTypesError","withTypes","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","rule","shouldUseRule","definition","hasApplicableType","kwdT","schTs","checkKeywordTypes","checkStrictTypes","block","keywordCode","useDefaults","assignDefaults","checkStrictMode","default","strictSchema","checkNoDefault","resetEvaluated","return","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","KeywordCxt","validateKeywordUsage","getData","validSchemaType","JSON","condition","successAction","failAction","invalid$data","append","errorParams","errorPaths","_error","reportExtraError","$dataError","keyword$DataError","resetErrorsCount","obj","codeBlock","$dataValid","check$data","validateSchema","st","wrong$DataType","validateSchemaRef","invalid$DataSchema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","resolveUrl","updateContext","checkAsyncSchema","subSchemaObjCode","boolOrEmptySchema","subschemaCode","schemaCxt","toName","mergeValidEvaluated","ruleType","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","segments","split","segment","getProperty","unescapeJsonPointer","pointerType","names","scope","json","jsonPos","jsonLen","jsonPart","META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","_addVocabularies","super","addVocabulary","discriminator","addKeyword","_addDefaultMetaSchema","metaSchema","$dataMetaSchema","draft7MetaSchema","addMetaSchema","refs","defaultMeta","getSchema","defineProperty","CodeGen","core","fmtDef","compare","fullFormats","date","compareDate","time","compareTime","dateTime","DATE_TIME_SEPARATOR","compareDateTime","duration","uri","NOT_URI_FRAGMENT","URI","url","email","hostname","ipv4","ipv6","regex","Z_ANCHOR","uuid","byte","BYTE","lastIndex","int32","Number","isInteger","MAX_INT32","MIN_INT32","int64","float","validateNumber","double","password","binary","fastFormats","formatNames","DATE","DAYS","year","month","day","isLeapYear","d1","d2","TIME","withTimeZone","hour","minute","second","timeZone","t1","t2","a1","a2","dt1","dt2","res","validateUnion","ajv","validation","AJV_CONFIG","multipleOfPrecision","strict","verbose","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","processRawValidationErrors","validator","rawErrors","formData","customValidate","transformErrors","uiSchema","validationError","invalidSchemaError","rest","property","replace","stack","trim","missingProperty","currentProperty","uiSchemaTitle","getUiOptions","title","parentSchemaTitle","PROPERTIES_KEY","transformRJSFValidationErrors","errorSchema","toErrorSchema","$schema","__errors","newFormData","getDefaultFormState","errorHandler","createErrorHandler","userErrorSchema","unwrapErrorHandler","validationDataMerge","AJV8Validator","options","localizer","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","addFormat","ADDITIONAL_PROPERTY_FLAG","RJSF_ADDITONAL_PROPERTIES_FLAG","formatName","createAjvInstance","toErrorList","fieldPath","rawValidation","compilationError","compiledValidator","ID_KEY","err","validateFormData","isValid","rootSchema","rootSchemaId","ROOT_SCHEMA_PREFIX","addSchema","schemaWithIdRefPrefix","withIdRefPrefix","hashForSchema","console","removeSchema","customizeValidator","AJV8PrecompiledValidator","validateFns","mainValidator","getValidator","ensureSameRootSchema","resolvedRootSchema","retrieveSchema","JUNK_OPTION_ID","createPrecompiledValidator","DiscrError","schemaHasRules","escapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","from","to","evaluatedPropsToName","ps","setEvaluated","arr","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","max","snippets","mode","_Code","jsPropertySyntax","isNumber","Num","implements","kwd","fullName","fastName","formatsPlugin","addFormats","formats","exportName","list","fs","get","u","unicodeRegExp","regExp","traverse","cb","_traverse","pre","jsonPtr","parentJsonPtr","parentKeyword","keyIndex","arrayKeywords","propsKeywords","prop","escapeJsonPtr","allKeys","skipKeywords","additionalItems","contains","additionalProperties","propertyNames","then","allOf","anyOf","oneOf","$defs","definitions","dependencies","enum","required","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","maxLength","minLength","pattern","format","maxItems","minItems","uniqueItems","maxProperties","minProperties","defaultRegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","requiredOptions","o","s","_optz","optimize","strictTuples","strictRequired","loopRequired","messages","inlineRefs","addUsedSchema","validateFormats","int32range","schemas","_compilations","_loading","_cache","Map","lines","ValueScope","prefixes","noLogs","log","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","addInitialKeywords","addInitialSchemas","_dataRefSchema","$dataRefSchema","id","$id","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","async","_schema","loadMetaSchema","_compileAsync","checkLoaded","loadMissingSchema","missingSchema","missingRef","_loadSchema","_validateSchema","normalizeId","_checkUnique","throwOrLogError","errorsText","keyRef","getSchEnv","resolveSchema","_removeAllSchemas","clear","delete","cacheKey","kwdOrDef","checkKeyword","eachItem","addRule","keywordMetaschema","k","getKeyword","removeKeyword","findIndex","splice","separator","dataVar","reduce","text","keywordsJsonPointers","parse","slice","seg","schemaOrData","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","checkOpts","opt","optsSchemas","defs","metaOpts","MissingRefError","KEYWORD_NAME","ruleGroup","find","before","addBeforeRule","_rule","$dataRef","schemaProp","resolver","getFullPath","ifClause","hasThen","hasSchema","hasElse","schValid","validateIf","validateClause","draft7Vocabularies","fmts","fDef","fType","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtType","fmtRef","regexpCode","fmt","getFormat","validCondition","validateFormat","strConcat","Scope","ValueScopeName","varKinds","GTE","LTE","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_names","_constants","Def","varKind","rhs","render","_n","constants","optimizeExpr","_CodeOrName","Assign","lhs","sideEffects","addExprNames","AssignOp","Label","Break","Throw","AnyCode","ParentNode","nodes","n","subtractNames","addNames","BlockNode","Root","Else","kind","If","ns","For","ForLoop","iteration","ForRange","ForIter","loop","iterable","Func","args","Return","Try","catch","finally","Catch","Finally","replaceName","_items","c","par","extScope","_values","_blockStarts","_extScope","_scope","parent","_nodes","_root","prefix","scopeName","prefixOrName","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","_leafNode","_constant","keyValues","addCodeArg","thenBody","elseBody","_blockNode","_elseNode","_endBlockNode","_for","node","forBody","endFor","forRange","ownProperties","tryBody","catchCode","finallyCode","_currNode","nodeCount","endBlock","pop","toClose","funcBody","endFunc","N1","N2","andCode","mappend","orCode","y","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","passSchema","modifying","reportErrs","ruleErrs","validateAsync","validateErrs","validateSync","extendErrors","addErrs","deps","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","count","Infinity","normalize","_getFullPath","TRAILING_SLASH_HASH","resolve","ANCHOR","baseIds","pathPrefix","schemaRefs","fullPath","addRef","_resolve","ambiguos","schOrRef","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","validateTuple","validateArray","extraItems","schArr","l","fullTuple","checkStrictTuple","allProps","definedProperties","hasDefault","applyPropertySchema","propertyInData","hasPropFunc","noPropertyInData","schemaMap","missing","errorPath","context","dataAndSchema","newRegExp","rx","validArr","validateItems","notValid","_sch","draft2020","applicator","addError","errObj","returnErrors","keywordError","overrideAllErrors","errorObjectCode","E","errorInstancePath","errorSchemaPath","extraErrorProps","errorObject","instPath","getErrorPath","schPath","merge","sets","xl","subexp","typeOf","shift","toLowerCase","toUpperCase","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","SUB_DELIMS$$","RESERVED$$","SCHEME$","USERINFO$","UNRESERVED$$","DEC_OCTET_RELAXED$","H16$","LS32$","IPV4ADDRESS$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","ZONEID$","IPV6ADDRESS$","IP_LITERAL$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","HOST$","REG_NAME$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","QUERY$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","IPRIVATE$$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","maxInt","base","regexPunycode","regexNonASCII","regexSeparators","floor","stringFromCharCode","String","fromCharCode","RangeError","mapDomain","fn","parts","ucs2decode","output","counter","extra","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","baseMinusTMin","decode","input","inputLength","bias","basic","lastIndexOf","index","oldi","w","baseMinusT","out","fromCodePoint","encode","currentValue","basicLength","handledCPCount","m","handledCPCountPlusOne","q","qMinusT","punycode","SCHEMES","pctEncChar","chr","pctDecChars","newStr","il","parseInt","substr","c2","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","UNRESERVED","scheme","PCT_ENCODED","NOT_SCHEME","userinfo","NOT_USERINFO","host","NOT_HOST","path","NOT_PATH","NOT_PATH_NOSCHEME","query","NOT_QUERY","fragment","NOT_FRAGMENT","_stripLeadingZeros","_normalizeIPv4","IPV4ADDRESS","address","_normalizeIPv6","IPV6ADDRESS","zone","reverse","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","longestZeroFields","acc","field","lastLongest","sort","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","uriString","iri","IRI_PROTOCOL","URI_PROTOCOL","reference","port","isNaN","indexOf","schemeHandler","unicodeSupport","domainHost","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","uriTokens","authority","$1","$2","_recomposeAuthority","charAt","absolutePath","resolveComponents","relative","target","tolerant","unescapeComponent","handler","secure","http","isSecure","wsComponents","resourceName","ws","O","VCHAR$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","mailtoComponents","unknownHeaders","headers","hfields","hfield","toAddrs","subject","addr","setInterval","toAddr","atIdx","localPart","domain","URN_PARSE","urnComponents","nid","nss","urnScheme","uriComponents","UUID","uuidComponents","https","wss","mailto","urn","baseURI","relativeURI","schemelessOptions","uriA","uriB","ESCAPE","prec","invalid","prefixItems","validateAdditionalItems","getCompilingSchema","rootId","_ValidationError","validateFunctionCode","validateCode","Function","makeValidate","scopeValues","inlineOrCompile","inlineRef","schEnv","sameSchemaEnv","s1","s2","refPath","getJsonPointer","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","part","partSchema","unescapeFragment","discrError","tagName","Tag","tag","mapping","applyTagSchema","_valid","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","addMapping","tagValue","getMapping","Mapping","validateMapping","boolError","falseSchemaError","depsCount","property_ies","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","hasProperty","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","ops","KWDs","okStr","assignDefault","defaultValue","childData","ty","IDENTIFIER","emptyStr","_str","strs","plus","safeStringify","mergeExprItems","arg","c1","passing","ValueError","UsedValueState","_prefixes","_parent","_newName","_nameGroup","nameStr","setValue","itemIndex","scopePath","line","valueKey","vs","_name","values","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","Completed","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","escapeFragment","dpType","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","min","minContains","maxContains","next","validateItemsWithCount","checkLimits","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","checkMatchingProperties","pat","validateProperties","alwaysValid","validatePatternProperties","formatMaximum","formatMinimum","formatExclusiveMaximum","formatExclusiveMinimum","formatLimitDefinition","fCxt","compareCode"],"sourceRoot":""}